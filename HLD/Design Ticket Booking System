Core Requirements:

Users should be able to view events
Users should be able to search for events
Users should be able to book tickets to events


__________________________

NON NF Requirements:

Consistency - for booking tickets

Availability - for searching events, view events

Realiability - no two users should book the same seats

Scalability

Fault tolerant

Secure - User info

Payment - 3rd party secure


____________________________


System is ready heavy.

Large Number of people will  be hitting out apis once the slot is open to book their tickets.
But there will be limited seats only


______________________________


Core Compenents are :

User
EVent - event details, performers, agebda
Performer - list of songs..performer details 
Venue 
Ticket
Booking

___________

Ticket - 

TicketId - 
Date -  (if its a 3/4 day event, then we need exipraration)
seat details (like section, row, and seat number), 
pricing, and 
status (available or sold)

_______________

Booking - 

Tickets : List[Ticket]
User
Price

1:1 b/w ticket and user

_________________________________



APIS:

-> Users should be able to view events

/get Events speciufy all events - over 3-4 days
if sslected data - show that day's ticket only.


-> Users should be able to search for events

-> spcify fields and perform LIKE operations on DB
GET /events/search?keyword={keyword}&start={start_date}&end={end_date}&pageSize={page_size}&page={page_number} -> Event[]



-> POST Endpoint

When it comes to purchasing/booking a ticket, we have a post endpoint that takes
the list of tickets and payment details and returns a bookingId.


we'll evolve this into two separate endpoints - one for reserving a ticket 
and one for confirming a purchase, but this is a good starting point.



______________________


Design:


user -> LB -> Event Service -> Event DB : Event table, Performer table , Venue Table , Ticket , User

            -> Search 

            -> Booking Service  
                      ^
                      |
                 payment(Stripe)


______________________________


DB : Consistency - for event Booking - PostgresDb'


_______________________________


Cache DB queries - read queries


Search - use elastic for full text search 

To make sure the data in Elasticsearch is always in sync with the data in our SQL DB, we can use change data capture (CDC) 
for real-time or near-real-time data synchronization from PostgreSQL to Elasticsearch. 

This setup captures changes in the PostgreSQL database, such as inserts, updates, and deletes, and replicates them 
to the Elasticsearch index.
We can enable fuzzy search functionality with Elasticsearch, which allows for error tolerance in search queries.
This is way we can handle typos and slight variations in spellings such as "Taylor Swift" vs "Tayler Swift". This is something that would be very difficult to do with SQL alone.



How can you speed up frequently repeated search queries and reduce load on our search infrastructure?

-> Redis Cache

-> Elastic Queries - elastic search Cache

-> We can also utilize CDNs to cache search results geographically closer to the user, 
reducing latency and improving response times.




Booking

Booking system - we should not allow the user forever to book or make
the payment for fair ticket booking system.
i.e, a particular user shuldnt "HOLD THE RESOURCES" longer


Booking service will - communicate with tickets and booking table.
and update accordingly



How do we implement this?
So we give user a timer to reserve the ticket and 
open the external payment service to make the payment, and we have a timer, within which the 
window closes.

Lets say the payment should be done in 2-5mins.
or else the ticket will be released.

If payment is successful -> update sttaus to booked
else update to -> Available


Ticket status is an IMP factor here - We need to update accordingly.
Reserved / Booked / Available


We need to ensure that the seat map is always up to date and that users are notified of changes in real-time.

Reserved means - we need to acquire lock on the resources.

How locking - 

1. DB locks
2. Distributed Locking - 


Another great solution is to implement a distributed lock with a TTL (Time To Live) using a distributed system like Redis. Redis is an in-memory data store that supports distributed locks and is well-suited for high-concurrency environments. It offers high availability and can be used to implement a distributed lock mechanism for the ticket booking process. Here is how it would work:
When a user selects a ticket, acquire a lock in Redis using a unique identifier (e.g., ticket ID) with a predefined TTL (Time To Live). This TTL acts as an automatic expiration time for the lock.
If the user completes the purchase, the ticket's status in the database is updated to "Booked", and the lock in Redis is manually released by the application after the TTL.
If the TTL expires (indicating the user did not complete the purchase in time), Redis automatically releases the lock. This ensures that the ticket becomes available for booking by other users without any additional intervention.
Now our Ticket table only has two states: available and booked. Locking of reserved tickets is handled entirely by Redis. The key-value pair in Redis is the ticket ID and the value is the user ID. This way we can ensure that when a user confirms the booking, they are the user who reserved the ticket.

















           








