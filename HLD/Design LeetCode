Design LeetCode


https://systemdesignschool.io/problems/leetcode/solution



There is a question bank that stores thousands of programming questions. 

-> For each question, users can write, compile and submit code against test cases and get results.
User submitted code needs to be persisted. 

Every week, there is a contest where people compete to solve questions as quickly as possible.
Users will be ranked based on their accuracy and speed. 
Weâ€™ll need a leaderboard that shows rankings in real time


LEADERBOARD IN timetime - REDIS

______________________________________________



Functional Requirments : 

View Problems: Users should be able to view problem descriptions, examples, constraints, and browse a list of problems.

Submit Solution: Users should be able to solve coding questions by submitting their solution code and running it against built-in test cases to get results.

Coding Contest: User can participate in coding contest. The contest is a timed event with a fixed duration of 2 hours consisting of four questions. 
The score is calculated based on the number of questions solved and the time taken to solve them. 
The results will be displayed in real time.

The leaderboard will show the top 50 users with their usernames and scores.



______________________________________________



NF - 

Scalable 
Available
COnsistent
Support Isolation when submitting User code

So if user solved a question, its fine even if it takes few secs to display - so vaavilable

__
___________________________________________


APIS:



GET /problems/{problem_id}
Get problem details, including description, constraints, examples, and starter code.

Response Body:

{
  id: string
  title: string
  difficulty: string
  description: string
  constraints: string
  examples: [{
    input: string
    output: string
  }]
  starter_code: {
    language: string
    code: string
  }
}



__________



POST /problems/{problem_id}/submission
Submit code for a problem and get results.

Response Body:

{
  status: success | fail
  test_cases: [
    { status: success | fail | timeout }
  ]
}


______



GET /contests/{contest_id}/leaderboard
Get leaderboard for a contest.

Response Body:

{
  ranking: [
    { user_id: string, score: number }
  ]
}



________________________________


DESIGN:

To design the code evaluation flow for our LeetCode-like platform, we need to consider the high concurrency requirement of 10,000 users participating
in contests simultaneously, each submitting solutions about 20 times on average.


Design :

User  ->  LB  ->  Code EVal Service  ->      QUEUE      ->    EVAL WORKERS -  Which process the requests of avaluations to run against test cases
                                          queue submissions




We use a Code Evaluation Service as the entry point for code submissions. 

This service will be responsible for receiving code from users and initiating the evaluation process. 
.
However, to handle the high volume of submissions efficiently and securely, we introduce a Message Queue as a buffer between
the submission process and the actual code execution.


Also this msg queue maybe a over engineering
As the contest doesnt scale upto much unknowingly, so we can pre-scale



When a user submits a solution, the Code Evaluation Service pushes a message containing the submission details (user ID, problem ID, and code) to the Message Queue.
This decouples the submission process from the execution process, allowing us to handle traffic spikes more effectively.





______________________________________________________



Coding Contest:


User can participate in coding contest. The contest is a timed event with a fixed duration of 2 hours consisting of four questions. 
The score is calculated based on the number of questions solved and the time taken to solve them. The results will be displayed in real time. 

The leaderboard will show the top 50 users with their usernames and scores.

A contest itself is bascially four problems with a time window.



We can use a centralized service to manage the contest.

Contest Service:

After a user submits a solution, it's graded by the Code Evaluation Service as described in the previous section. 
The results are then sent to the Contest Service to record the user's score in the database.


User  ->  LB  ->  Code EVal Service -> ......

     User -> Code Eval Service -> to evaluate the scores ->  Contest Service             

__________________________


Users should be able to submit their solution and get instant feedback


Code eval service need to exceute the code of each user and give instant feedback as to how may passed how many fialed and all.

SO we can have 2 types of test cases:

1. Sample test cases
2. submit solution - the final test cases _ larger Number


At the first attempt there are chances users does wrong and there could be erros.
SO insyed of runnign the code against all the tets cases everytime we can run only for a sample no.of test cases for user to fix issues.
This needs to be done instantly.

For submit slutuion - we can take some time.


_______________________


WHere to run and excute the code?

-> Run on API server  - We cant run the code on the api server because what if the user types in malformed cord and submits it will break our system.

-> We can run on VMs -  A VM is an isolated environment that runs on top of your server and can be easily reset if something goes wrong. 
This means that even if the user's code crashes the VM, it won't affect your server or other users.

But VMs are resource intensive.


-> We can run on containner(Docker) - Containers are similar to VMs in that they provide an isolated environment for running code,
but they are much more lightweight and faster to start up.


























The key decision here is where to store the contest data, user's score, and the leaderboard.

We need real time updates for the leaderboard and data changes frequently. 
We can use an in-memory database like Redis to store the leaderboard. Redis is a fast, in-memory database that is well suited for high performance, real time data processing




