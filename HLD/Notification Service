At a high level, any notification system has a few key parts. First, you have the Event Producers. These are the services that generate events, like a 'like' service or a 'comment' service. When an action happens, they send a message.

Next, this message doesn't go directly to the user. It goes to a central Notification Service. This service is the brain. It needs to figure out who should receive the notification. For a 'like' on a photo, it's the photo's owner. For a comment, it could be the post owner and anyone tagged.

To handle the massive volume of these events, we use Message Queues like Kafka or RabbitMQ. These act as a buffer, ensuring that even if the Notification Service is temporarily overwhelmed, no events are lost. This decoupling is crucial for a resilient architecture.

Finally, once the Notification Service determines the recipients, it needs to actually send the push notification. It does this by communicating with third party Push Notification Services like Apple Push Notification Service (APNs) for iOS and Firebase Cloud Messaging (FCM) for Android.




The Billion User Problem: Fanout
The real complexity comes with scale. Imagine a celebrity with 100 million followers posts an update. How do you notify all of them instantly? This is the classic fanout problem.

Fanout on Write is a common approach. When the celebrity posts, the system immediately identifies all 100 million followers and generates a notification for each one, pushing them into a queue. This is great for the followers because the notification is ready to be read instantly. However, it creates a massive write load on your system. It's a 'write storm'.

Alternatively, you could use Fanout on Read. When a user opens their app, the system checks all the people they follow to see if there are any new updates. This is easier on your write system but creates a heavy read load and isn't suitable for real time push notifications. For our use case, a well optimized Fanout on Write strategy is generally preferred.

In an interview, discussing the tradeoffs between these approaches and considering a hybrid model for users with a huge number of followers shows a deep level of understanding.






Notification Service  - client agnostic SHould send updates whthers its a web app, app.


What is FCM?

FCM is Google’s push notification service used to send notifications to:

Android apps
Web apps
iOS apps (via APNS bridge)

Why FCM is used

Reliable delivery
Handles device connectivity
Manages token routing
Scales automatically


You don’t talk directly to devices — you talk to FCM.


Why FCM fits push notification systems

No need to manage device connections
Built-in retries
Works well with async queues + batching




        ┌───────────────────┐
        │   Business        │
        │   Services        │
        │ (Order / Payment  │
        │  Delivery etc.)   │
        └────────┬──────────┘
                 │
                 │ Notification Event
                 ▼
        ┌──────────────────────┐
        │ Notification API /   │
        │ Orchestrator Service │
        └────────┬─────────────┘
                 │
      ┌──────────┴───────────┐
      │                      │
      ▼                      ▼
┌───────────────┐    ┌──────────────────┐
│ Token Registry│    │ Fan-out Engine   │
│ Service + DB  │    │ (Async)          │
└───────────────┘    └────────┬─────────┘
                              │
                              │ Enqueue per token
                              ▼
                    ┌──────────────────┐
                    │ Message Queue    │
                    │ (Kafka / SQS)    │
                    └────────┬─────────┘
                             │
             ┌───────────────┴───────────────┐
             │                               │
             ▼                               ▼
    ┌──────────────────┐            ┌──────────────────┐
    │ Push Worker      │            │ Push Worker      │
    │ (FCM)            │            │ (APNS)           │
    │ Batch + Retry    │            │ Batch + Retry    │
    └────────┬─────────┘            └────────┬─────────┘
             │                                │
             ▼                                ▼
      ┌──────────────┐                ┌──────────────┐
      │ FCM Provider │                │ APNS Provider│
      └──────────────┘                └──────────────┘
             │                                │
        Success / Failure               Success / Failure
             │                                │
             └──────────────┬────────────────┘
                            ▼
                 ┌──────────────────┐
                 │ Retry / DLQ      │
                 │ (Backoff + CB)   │
                 └──────────────────┘





Example with multiple users
User U1

Phone (Android)

Customer App → Token T1
Delivery App → Token T2

Tablet (Android)
Customer App → Token T3



User U2

Phone (iOS)
Customer App → Token T4

Phone (Android)
Restaurant App → Token T5




Clients register tokens and request notifications.

Notification API validates and routes requests.
Token Registry Service stores and manages device/app tokens.
Orchestrator fetches tokens and performs async fan-out.
Messages go to Queue for decoupling and buffering.

Workers consume messages:
Batch notifications
Apply retry + exponential backoff
Use circuit breaker per provider

Providers (FCM/APNS) deliver notifications.
Failures beyond retries go to DLQ for analysis.







Who sends the request for token registration?
✅ The client app itself

Flow

Mobile / Web App
   ↓
Token Registry API

Why client?

Token is generated inside the app by FCM/APNS
Backend cannot generate or guess it

Only the app knows:
current token
refresh events
uninstall/reinstall lifecycle

Typical registration flow (very important)

User logs in

App gets token from FCM/APNS

App calls backend

POST /tokens/register
{
  "userId": "U1",
  "deviceId": "D1",
  "appType": "CUSTOMER",
  "platform": "ANDROID",
  "provider": "FCM",
  "token": "T1"
}


Backend stores / updates token



Who sends requests to Notification Orchestrator?
✅ Backend services, not clients

Examples:

Order Service

Payment Service

Delivery Service

Admin tools

Order Service
   ↓
Notification Orchestrator



Very important interview distinction (say this)

“Token registration APIs are client-facing, notification orchestration APIs are internal service-to-service.”

This line alone clears confusion and scores points.






