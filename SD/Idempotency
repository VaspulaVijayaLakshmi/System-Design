Imagine you're making a purchase from an online store.
You hit "pay" but the screen freezes, and you're unsure if the payment went through.
So, you refresh the page and try again.

Behind the scenes, how does the system ensure you aren’t accidentally charged twice?


This scenario highlights a common problem in distributed systems: handling repeated operations gracefully.

The solution to this problem lies in the concept of idempotency.



IDEMPOTENCY : 

In mathematics, an operation is idempotent if applying it multiple times produces the same result 
as applying it once.

Eg: the absolute value function is idempotent: ||-5|| = |-5| = 5.
Eg:  setting a value is idempotent, while incrementing a value is not.




Why Idempotency Matters ?


Distributed systems often require fault tolerance to ensure high availability.
When a network issue causes a timeout or an error, the client might retry the request.

If the system handles retries without idempotency, every retry could change the 
system’s state unpredictably.





DB Operation : 

Some database operations, such as inserting the same record multiple times,
can lead to unintended duplicate entries.

This can involve using upsert operations (which updates a record if it exists or inserts it otherwise)
or applying unique constraints that prevent duplicates from being added in the first place.

DB INSERT Operation isnot idempotent..






Idempotency in Messaging Systems

We maintain alog of processed requetss and and checking against it for every incoming message.

```
import java.util.HashSet;
import java.util.Set;

public class MessageConsumer {

private Set<String> processedMessages = new HashSet<>();

public void processMessage(String messageId, String messageContent) {
if (processedMessages.contains(messageId)) {
System.out.println("Duplicate message ignored: + messageId); 11
return;
}


// Process the message here
System.out.println("Processing message: + messageContent); 11
// Add messageId to processed set
processedMessages.add(messageId);
}

}
```


Use Locks or Versioning: Use locks, optimistic concurrency control, or version numbers to manage simultaneous requests safely.









What Does “Idempotent” Mean?

Idempotent means:
Performing the same operation multiple times has the same effect as performing it once.



Analogy:

If you press the “Mute” button once or five times —
the outcome is still “muted”.
That’s idempotence.

But pressing “Increase Volume” multiple times increases it each time —
not idempotent.




Idempotent APIs in HTTP

Some HTTP methods are designed to be idempotent by spec:

```
HTTP                  Method	             Idempotent?	Why
GET	                   Yes	               Doesn’t change state
PUT                    Yes	               Replaces resource (same input = same state)
DELETE	               Yes	               Deleting again has no effect
POST	                 No	                 Creates a new resource each time (can cause duplicates)
```



Non-Idempotent:

```
POST /payments
Body: { "amount": 100, "userId": 5 }

Call it twice → user might get charged twice 
```



Idempotent:
```
PUT /payments/{paymentId}
Body: { "amount": 100, "userId": 5 }


Call it twice → only one payment with paymentId created/updated.
```








How to Design Idempotent APIs (esp. POSTs)

Even POST can be made idempotent using a unique key.

 1️⃣ Idempotency Key

Client generates a unique idempotency-key for each logical request.

```
POST /payments
Headers: Idempotency-Key: abcd-1234
Body: { "amount": 100, "userId": 5 }
```



2️⃣ Check for Duplicate Requests

Server stores (key → result) mapping.
If the same key is sent again → return cached response, don’t reprocess.
Stripe, PayPal, and AWS APIs use this approach.



Check for Duplicate Requests
Before processing, check DB for an existing transaction/order ID.
If found → skip processing, just return success.








Problem	                                Without Idempotency	               With Idempotency

Network retry	                           Might process twice	                Safe to retry
Client resend	                           Creates duplicates	                   Safe
Server crash mid-request	                Reprocessing causes duplicates	       Safe recovery
Exactly-once behavior (like Kafka)	         Impossible	               Achievable

Idempotency is the foundation for safe retries and exactly-once semantics in distributed systems.


