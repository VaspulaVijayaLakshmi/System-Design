Logging Levels

Logging is the process of recording events or messages generated by a program during its execution — typically written to a file, console, or external system (like ELK, Splunk, or CloudWatch).

These logs help developers and operators understand what the software is doing, diagnose issues, and monitor system health over time.


Key purposes:

Debugging – Find out what led to an error or crash.
Monitoring – Track application performance, usage patterns, and uptime.
Auditing – Maintain a record of user or system actions (for compliance/security).
Analytics – Derive insights like how often certain APIs are hit.
Alerting – Integrate with tools that trigger alerts on error or failure logs.



Logging levels are used to classify the importance and severity of log messages:


Level	Purpose	Typical Use:

Least Level :  TRACE	Very detailed, step-by-step execution info.	Tracing program flow, debugging complex logic, low-level debugging (e.g., DB queries, loops).
                DEBUG	Diagnostic info useful for debugging.	Variable values, function entry/exit, internal state. Disabled in production.
                INFO	General application flow and state.	Startup/shutdown messages, successful operations (e.g., “User logged in”).
                WARN	Something unexpected happened, but program continues.	Deprecated API use, retrying a failed request, performance issues.
High Level:     ERROR	A serious problem occurred, an operation failed.	Failed DB call, exception handling, file not found, etc.



```
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyApp {
    private static final Logger logger = LoggerFactory.getLogger(MyApp.class);

    public static void main(String[] args) {
        logger.trace("Entering main method...");
        logger.debug("Debugging user input...");
        logger.info("Application started successfully.");
        logger.warn("Low memory detected.");
        logger.error("Failed to connect to database.");
    }
}
```



TRACE logs record fine-grained information about a program’s internal behavior — every method call, condition, and intermediate step.



logger is a static class-level variable

Let’s break it down:

static → Belongs to the class, not to any instance.
So it’s shared by all objects of that class.
You don’t need to create an object of MyService to use it — you can call it directly.

final → Once assigned, it cannot be reassigned.
(You don’t want your logger reference changing midway.)

LoggerFactory.getLogger(MyService.class) →
Creates a logger specific to this class name.
So all logs from MyService will be tagged with its class name automatically — super helpful when debugging.




